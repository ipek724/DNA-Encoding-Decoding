# 📄 مستندات پروژه

## 1. `1.ipynb`

این کد، الگوریتم و روش کدگذاری هافمن را پیاده‌سازی می‌کند. هر بخش از این کد توضیح داده شده است:

### وارد کردن کتابخانه‌ها:
- **heapq**: برای مدیریت اولویت‌ها در هرم (heap).
- **graphviz**: برای رسم نمودار درخت.
- **json**: برای بارگذاری داده‌های احتمالی.

### کلاس `HuffmanNode`:
- **متغیر `probability`**: ذخیره کننده احتمال رخداد یک نماد.
- **متغیر `symbols`**: ذخیره کننده لیست نمادها.
- **متغیر `children`**: ذخیره کننده فرزندان هر گره.

### تابع `__lt__` در کلاس `HuffmanNode`:
این تابع برای مقایسه احتمالات دو گره استفاده می‌شود تا گره با احتمال کمتر اولویت بیشتری داشته باشد.

### تابع `build_huffman_tree`:
این تابع درخت هافمن را بر اساس احتمالات نمادها می‌سازد. ابتدا، تمامی نمادها به گره‌های هافمن تبدیل می‌شوند و در یک هرم قرار می‌گیرند. تا زمانی که تعداد گره‌ها بیشتر از ۴ باشد، چهار گره با احتمال کم انتخاب می‌شوند و به عنوان فرزندان یک گره والد جدید قرار می‌گیرند. در نهایت، گره ریشه ایجاد می‌شود که شامل تمامی گره‌ها به عنوان فرزند است.

### تابع `generate_tree_image`:
این تابع نمودار درخت هافمن را با استفاده از graphviz ایجاد می‌کند.

### تابع `generate_node_image`:
این تابع گره‌های درخت را به نمودار اضافه می‌کند و برچسب‌ها و احتمالات هر گره را نمایش می‌دهد.

### بارگذاری داده‌ها از فایل‌های JSON:
احتمالات نمادها و دیکشنری‌های رمزگذاری بارگذاری می‌شوند.

### مثال استفاده:
- ساخت درخت هافمن با استفاده از احتمالات.
- تولید کدها از درخت.
- ایجاد و نمایش نمودار درخت هافمن با استفاده از graphviz.

این کد نشان می‌دهد که چگونه الگوریتم هافمن می‌تواند برای کدگذاری داده‌ها استفاده شود و چگونه می‌توان درخت هافمن را به صورت بصری نمایش داد.

---

## 2. `main store.ipynb`

این کد پیاده‌سازی یک الگوریتم برای محاسبه و تولید بیت‌های اضافی (Redundant Bits) برای کدگذاری هافمن و همچنین تجزیه و تحلیل داده‌های DNA است. بیایید بخش‌های مختلف این کد را تحلیل کنیم:

### توابع
#### تابع `calcRedundantBits(m)`
```python
def calcRedundantBits(m):
    for i in range(m):
        if(2**i > m + i + 1):
            return i
