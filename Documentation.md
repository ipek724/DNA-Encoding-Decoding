
# 📄 مستندات پروژه کدگذاری و بررسی داده‌های DNA

## 1. **فایل: `1.ipynb`**
این کد الگوریتم و روش کدگذاری هافمن را پیاده‌سازی می‌کند. هر بخش از این کد توضیح داده شده است:

### وارد کردن کتابخانه‌ها:
- `heapq`: برای مدیریت اولویت‌ها در هرم (heap).
- `graphviz`: برای رسم نمودار درخت.
- `json`: برای بارگذاری داده‌های احتمالی.

### کلاس `HuffmanNode`:
- **متغیر `probability`**: ذخیره کننده احتمال رخداد یک نماد.
- **متغیر `symbols`**: ذخیره کننده لیست نمادها.
- **متغیر `children`**: ذخیره کننده فرزندان هر گره.

### تابع `__lt__` در کلاس `HuffmanNode`:
این تابع برای مقایسه احتمالات دو گره استفاده می‌شود تا گره با احتمال کمتر اولویت بیشتری داشته باشد.

### تابع `build_huffman_tree`:
این تابع درخت هافمن را بر اساس احتمالات نمادها می‌سازد.
- تمامی نمادها به گره‌های هافمن تبدیل می‌شوند و در یک هرم قرار می‌گیرند.
- تا زمانی که تعداد گره‌ها بیشتر از ۴ باشد، چهار گره با احتمال کم انتخاب می‌شوند و به عنوان فرزندان یک گره والد جدید قرار می‌گیرند.
- در نهایت، گره ریشه ایجاد می‌شود که شامل تمامی گره‌ها به عنوان فرزند است.

### تابع `generate_tree_image`:
این تابع نمودار درخت هافمن را با استفاده از graphviz ایجاد می‌کند.

### تابع `generate_node_image`:
این تابع گره‌های درخت را به نمودار اضافه می‌کند و برچسب‌ها و احتمالات هر گره را نمایش می‌دهد.

### بارگذاری داده‌ها از فایل‌های JSON:
احتمالات نمادها و دیکشنری‌های رمزگذاری بارگذاری می‌شوند.

### مثال استفاده:
- ساخت درخت هافمن با استفاده از احتمالات.
- تولید کدها از درخت.
- ایجاد و نمایش نمودار درخت هافمن با استفاده از graphviz.

این کد نشان می‌دهد که چگونه الگوریتم هافمن می‌تواند برای کدگذاری داده‌ها استفاده شود و چگونه می‌توان درخت هافمن را به صورت بصری نمایش داد.

---

## 2. **فایل: `2.ipynb`**
این کد پیاده‌سازی یک الگوریتم برای محاسبه و تولید بیت‌های اضافی (Redundant Bits) برای کدگذاری هافمن و همچنین تجزیه و تحلیل داده‌های DNA است. بیایید بخش‌های مختلف این کد را تحلیل کنیم:

### توابع
#### تابع `calcRedundantBits(m)`
```python
def calcRedundantBits(m):
    for i in range(m):
        if(2**i > m + i + 1):
            return i
```
**عملکرد**: این تابع تعداد بیت‌های اضافی (Redundant Bits) را محاسبه می‌کند.  
**الگوریتم**: با استفاده از فرمول \(2^r \geq m + r + 1\)، جایی که \(m\) تعداد بیت‌های اصلی است، تعداد صحیح \(r\) به عنوان تعداد بیت‌های اضافی بر می‌گرداند.

#### تابع `posRedundantBits(data, r)`
```python
def posRedundantBits(data, r):
    j = 0
    k = 1
    m = len(data)
    res = ''
    for i in range(1, m + r + 1):
        if(i == 2**j):
            res = res + '0'
            j += 1
        else:
            res = res + data[-1 * k]
            k += 1
    return res[::-1]
```
**عملکرد**: این تابع بیت‌های redundancy را در موقعیت‌های خاص (موقعیت‌های توان ۲) قرار می‌دهد.  
**خروجی**: داده اصلی به همراه بیت‌های اضافی را به صورت رشته‌ای برمی‌گرداند. همچنین رشته را معکوس می‌کند چرا که موقعیت‌ها به صورت معکوس شمارش می‌شوند.

#### تابع `calcParityBits(arr, r)`
```python
def calcParityBits(arr, r):
    n = len(arr)
    for i in range(r):
        val = 0
        for j in range(1, n + 1):
            if(j & (2**i) == (2**i)):
                val = val ^ int(arr[-1 * j])
        arr = arr[:n - (2**i)] + str(val) + arr[n - (2**i) + 1:]
    return arr
```
**عملکرد**: این تابع بیت‌های parities (زوجی) را برای بیت‌های اضافی محاسبه می‌کند.  
**الگوریتم**: برای هر بیت اضافی محاسبه می‌کند مقدار parity با استفاده از عملیات XOR بر اساس موقعیت بیت.

### خواندن و تجزیه و تحلیل داده‌ها
```python
text = open("./encode_output.txt", "r")
data = text.read()
text.close()
```
**عملکرد**: فایل متنی `encode_output.txt` خوانده می‌شود و محتویات آن در متغیر `data` ذخیره می‌شود.

### تبدیل رشته‌ها به رشته‌های DNA
```python
a = '00'
t = '01'
c = '10'
g = '11'
```
**عملکرد**: به هر کد دو بیتی معادل یک قاعده DNA نسبت داده می‌شود.

### جداسازی داده‌ها به بخش‌های کوچک‌تر
```python
seperator = 96
lenghtString = len(data)

listChar = []
string = ""

for counter in range(lenghtString):
    string += data[counter]
    if ((counter+1) % seperator == 0 and counter != 0) or counter == lenghtString - 1:
        listChar.append(string)
        string = ""
```
**عملکرد**: داده‌ها به بخش‌های ۹۶ تایی تقسیم می‌شوند و هر بخش در لیست `listChar` ذخیره می‌شود.

### تبدیل به DNA و کدگذاری
```python
addressString = []
...
for item in listChar:
    ...
    addressString.append(address + item)
```
**عملکرد**: به هر بخش کد بیت‌های دوتایی (00، 01، 10، 11) معادل یک قاعده DNA (A، T، C، G) نسبت داده می‌شود و در `addressString` ذخیره می‌شود.

### تولید رشته‌های باینری
```python
binaryString = []
...
for item in addressString:
    ...
    binaryString.append(string)
```
**عملکرد**: قاعده‌های DNA به رشته‌های باینری تبدیل می‌شوند و در `binaryString` ذخیره می‌شوند.

### تولید بیت‌های اضافی و بررسی parities
```python
for item in binaryString:
    ...
    m = len(listChar[counter-1])
    r = calcRedundantBits(m)
    arr = posRedundantBits(data, r)
    arr = calcParityBits(arr, r)
    ...
```
**عملکرد**: با استفاده از توابع پیشین، بیت‌های redundancy و parities را محاسبه می‌کند و به داده باینری اضافه می‌کند.

### ذخیره نتایج در فایل
```python
output = open("output.txt", "w")
output.writelines(characterString)
output.close()
```
**عملکرد**: نتایج نهایی در یک فایل متنی `output.txt` ذخیره می‌شود.

### نتیجه‌گیری
این کد شامل جداسازی، کدگذاری و محاسبه بیت‌های اضافی برای داده‌های دودویی است که نهایتاً به داده‌های DNA تبدیل می‌شود و به صورت متنی در یک فایل ذخیره می‌شود. این الگوریتم شامل محاسبه parity و استفاده از بیت‌های اضافی است تا به اطمینان از صحت اطلاعات کمک کند.

---

## 3. **فایل: `3.ipynb`**
این کد که در فایل `Main Retrieval.ipynb` قرار دارد، یک پروسه کدگذاری و بررسی صحت داده‌های مرتبط با ساختار DNA را به کمک الگوریتم‌های مربوطه انجام می‌دهد. بیایید به تفکیک به تحلیل هر بخش و تابع بپردازیم:

### 1. وارد کردن کتابخانه
```python
from colorama import Fore, Style
```
این خط کتابخانه `colorama` را وارد می‌کند که برای رنگ‌آمیزی متن در کنسول استفاده می‌شود.

### 2. توابع

#### تابع `calcRedundantBits(m)`
```python
def calcRedundantBits(m):
    for i in range(m):
        if(2**i > m + i + 1):
            return i
```
**عملکرد**: این تابع تعداد بیت‌های اضافی (Redundant Bits) را محاسبه می‌کند.  
**ورود**: تعداد بیت‌های اصلی (`m`) به عنوان ورودی.  
**خروج**: تعداد بیت‌های اضافی (`i`) که برای اطمینان از خطا در داده‌های کدگذاری شده لازم است.

#### تابع `posRedundantBits(data, r)`
```python
def posRedundantBits(data, r):
    j = 0
    k = 1
    m = len(data)
    res = ''
    for i in range(1, m + r + 1):
        if(i == 2**j):
            res = res + '0'
            j += 1
        else:
            res = res + data[-1 * k]
            k += 1
    return res[::-1]
```
**عملکرد**: این تابع بیت‌های اضافی را در موقعیت‌های خاص (توان‌های ۲) در کدگذاری قرار می‌دهد.  
**ورود**: داده باینری (`data`) و تعداد بیت‌های اضافی (`r`).  
**خروج**: رشته جدیدی که شامل بیت‌های داده و بیت‌های اضافی است.

#### تابع `calcParityBits(arr, r)`
```python
def calcParityBits(arr, r):
    n = len(arr)
    for i in range(r):
        val = 0
        for j in range(1, n + 1):
            if(j & (2**i) == (2**i)):
                val = val ^ int(arr[-1 * j])
        arr = arr[:n - (2**i)] + str(val) + arr[n - (2**i) + 1:]
    return arr
```
**عملکرد**: این تابع بیت‌های parity را برای داده‌های کدگذاری شده محاسبه می‌کند.  
**ورود**: آرایه داده (`arr`) و تعداد بیت‌های اضافی (`r`).  
**خروج**: آرایه جدید با بیت‌های parity محاسبه شده.

#### تابع `detectError(arr, nr)`
```python
def detectError(arr, nr):
    n = len(arr)
    res = 0
    for i in range(nr):
        val = 0
        for j in range(1, n + 1):
            if(j & (2**i) == (2**i)):
                val = val ^ int(arr[-1 * j])
        res = res + val * (10**i)
    return int(str(res), 2)
```
**عملکرد**: این تابع برای شناسایی خطا در داده‌های کدگذاری شده طراحی شده است.  
**ورود**: داده کدگذاری شده (`arr`) و تعداد بیت‌های parity (`nr`).  
**خروج**: عددی که نشان‌دهنده موقعیت خطا است.

### 3. خواندن داده از فایل
```python
first = open("./encode_output.txt", "r")
firstData = first.read()
first.close()
```
**عملکرد**: این بخش داده‌ها را از فایل متنی `encode_output.txt` می‌خواند.

```python
text = open("./output.txt", "r")
data = text.read()
text.close()
```
**عملکرد**: این بخش داده کدگذاری شده را از فایل `output.txt` می‌خواند.

### 4. تبدیل رشته‌های DNA به باینری
```python
a = '00'
t = '01'
c = '10'
g = '11'
```
این بخش مشخص می‌کند که هر پایه DNA به چه دو بیتی معادل است.

### 5. جداسازی رشته‌ها به بلوک‌های کوچکتر
```python
seperator = 128
```
داده کدگذاری شده به بخش‌های کوچکتری با طول حداکثر 128 کاراکتر تقسیم می‌شود و در لیستی به نام `listChar` ذخیره می‌شود.

### 6. تبدیل رشته‌های DNA به رشته‌های باینری
این بخش از کد، به هر کاراکتر A، T، C، و G رشته‌های دو بیتی مربوطه را نسبت می‌دهد:

```python
for item in listChar:
    for character in item:
        ...
    binaryString.append(string)
```

### 7. بررسی وجود خطا در داده‌ها و تصحیح آن‌ها
```python
for item in listChar:
    ...
    if len(item) == 32:
        correction = detectError(item, 6)
    ...
```
**عملکرد**: برای هر بلوک 32 کاراکتری از داده‌های کدگذاری شده، خطاها را بررسی کرده و در صورت وجود، آن‌ها را اصلاح می‌کند.

### 8. ذخیره داده‌های نهایی در فایل
```python
output = open("finalbinaryafter.txt", "w")
output.writelines(finalstring)
output.close()
```
**عملکرد**: داده‌های تصحیح شده را در فایلی با نام `finalbinaryafter.txt` ذخیره می‌کند.

### 📝 نتیجه‌گیری
این کد به طور کلی یک فرایند کدگذاری و بررسی صحت داده‌ها را با استفاده از اصول کدگذاری هافمن و تکنیک‌های مربوط به داده‌های DNA انجام می‌دهد. شامل محاسبات برای بیت‌های اضافی و parity و همچنین قابلیت شناسایی و اصلاح خطاهای موجود در داده‌ها می‌باشد.

---

## 6. **فایل: `main store.ipynb`**
این کد به ذخیره و مدیریت داده‌های DNA می‌پردازد و شامل توابع و الگوریتم‌هایی برای ذخیره اطلاعات می‌باشد:

### 1. وارد کردن کتابخانه‌ها
```python
import json
```
این خط کتابخانه `json` را وارد می‌کند که برای کار با فرمت JSON استفاده می‌شود.

### 2. تعریف توابع
#### تابع `store_data(data, filename)`
```python
def store_data(data, filename):
    with open(filename, 'w') as f:
        json.dump(data, f)
```
این تابع داده‌ها را در یک فایل JSON ذخیره می‌کند.

### 3. استفاده از تابع ذخیره‌سازی
```python
if __name__ == "__main__":
    data = {'A': 10, 'T': 20, 'C': 30, 'G': 40}
    store_data(data, 'data.json')
```
این بخش داده‌های DNA را در فایل JSON ذخیره می‌کند.

### 📝 نتیجه‌گیری
این کد به ذخیره داده‌های DNA در فرمت JSON می‌پردازد و شامل تابعی برای ذخیره‌سازی اطلاعات می‌باشد.
