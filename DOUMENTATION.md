# 📌 ذخیره‌سازی داده‌ها در DNA و تصحیح خطا

## 📖 مقدمه
با رشد تصاعدی داده‌های دیجیتال، فناوری‌های ذخیره‌سازی سنتی با چالش‌هایی مانند ظرفیت محدود، طول عمر کوتاه و تراکم پایین مواجه شده‌اند. ذخیره‌سازی داده در **DNA** به دلیل چگالی بالا (تا **700 ترابایت در هر گرم**) و طول عمر طولانی (**هزاران سال**) به عنوان یک جایگزین نوین مورد توجه قرار گرفته است. با این حال، ذخیره‌سازی و بازیابی کارآمد داده‌ها نیازمند حل چالش‌هایی مانند **مدیریت خطا، هزینه سنتز و کارایی کدگذاری** است.

🎯 **هدف این پروژه** ارائه روشی ترکیبی از **کدگذاری هافمن** برای فشرده‌سازی و **کدگذاری همینگ** برای تشخیص و تصحیح خطا است که باعث بهبود دقت ذخیره‌سازی و بازیابی داده‌ها می‌شود.

---
## ✨ ویژگی‌ها
✅ **فشرده‌سازی داده**: استفاده از **کدگذاری هافمن** برای کاهش حجم داده‌ها.
✅ **تشخیص و تصحیح خطا**: استفاده از **کد همینگ** برای خواندن و نوشتن صحیح داده‌ها.
✅ **رمزگذاری و رمزگشایی**: تبدیل متن به **رشته‌های DNA** و بازگردانی دقیق متن اصلی.
✅ **ذخیره‌سازی بهینه**: بهره‌گیری از **زیست‌محاسبات** برای بهبود ذخیره‌سازی داده در **محیط DNA**.

---
## 📂 ساختار فایل‌ها و توضیحات توابع
این مخزن شامل چندین **Jupyter Notebook** است که مراحل **کدگذاری، فشرده‌سازی، تصحیح خطا و بازیابی** داده‌ها را پیاده‌سازی می‌کند.

### 📌 1. فشرده‌سازی داده و تحلیل فرکانس (`1.ipynb`)
📌 **توابع اصلی:**
- `extract_text_from_pdf(file_path)`: خواندن و استخراج متن از PDF.
- `calculate_character_frequencies(text)`: شمارش تعداد کاراکترها.
- `build_huffman_tree(frequencies)`: ایجاد درخت هافمن.
- `generate_huffman_codes(tree)`: تولید دیکشنری کدگذاری.

### 📌 2. کدگذاری هافمن و جدول احتمالات (`2.ipynb`)
📌 **توابع اصلی:**
- `create_huffman_encoding_dict(frequencies)`: ایجاد دیکشنری کدگذاری.
- `save_encoding_table_to_csv(dictionary, filename)`: ذخیره جدول کدگذاری به CSV.
- `generate_probability_table(frequencies)`: ایجاد جدول احتمالات.

### 📌 3. تبدیل متن به DNA (`3.ipynb`)
📌 **توابع اصلی:**
- `text_to_binary(text, encoding_dict)`: تبدیل متن به دودویی.
- `binary_to_dna(binary_sequence)`: تبدیل داده‌ها به **DNA**.
- `save_dna_sequence_to_file(dna_sequence, filename)`: ذخیره داده **DNA** در فایل متنی.

### 📌 4. نمایش درخت هافمن (`4.ipynb`)
📌 **توابع اصلی:**
- `build_huffman_tree_graph(tree)`: نمایش گرافیکی درخت هافمن.
- `display_huffman_codes(codes)`: نمایش نگاشت کدهای هافمن.

### 📌 5. تشخیص و تصحیح خطا (`Main Retrieval.ipynb`)
📌 **توابع اصلی:**
- `apply_hamming_code(data)`: اعمال کد همینگ.
- `detect_and_correct_errors(encoded_data)`: شناسایی و اصلاح خطا.
- `decode_hamming(encoded_data)`: رمزگشایی داده‌های تصحیح‌شده.

### 📌 6. ذخیره‌سازی نهایی داده‌ها (`main store.ipynb`)
📌 **توابع اصلی:**
- `segment_dna_sequence(dna_sequence, segment_size)`: تقسیم داده‌های DNA.
- `save_segmented_dna_to_file(segments, filename)`: ذخیره بخش‌های داده.
- `retrieve_and_reconstruct_data(segments)`: بازیابی داده‌ها.

---
## ⚙️ نصب و پیش‌نیازها
برای اجرای کدها، کتابخانه‌های زیر را نصب کنید:
```bash
pip install pandas numpy PyPDF2 graphviz colorama reportlab
```
همچنین، برای اجرای فایل‌های `.ipynb` به **Jupyter Notebook** نیاز دارید.

---
## 🚀 راهنمای استفاده
1️⃣ **اجرای `1.ipynb`** برای پردازش ورودی و ایجاد جدول فرکانس.
2️⃣ **اجرای `2.ipynb`** برای دریافت نگاشت کدگذاری هافمن.
3️⃣ **اجرای `3.ipynb`** برای تبدیل متن به **DNA**.
4️⃣ **اجرای `4.ipynb`** برای نمایش درخت هافمن.
5️⃣ **اجرای `Main Retrieval.ipynb`** برای **تشخیص و تصحیح خطا**.
6️⃣ **اجرای `main store.ipynb`** برای ذخیره‌سازی نهایی داده‌ها.

---
## 📊 نتایج
✅ تبدیل موفقیت‌آمیز یک فایل متنی به **DNA**.
✅ فشرده‌سازی داده‌ها با **کدگذاری هافمن**.
✅ استفاده از **کد همینگ** برای **تشخیص و تصحیح خطا**.
✅ بازیابی **دقیق و صحیح متن اصلی**.

---
